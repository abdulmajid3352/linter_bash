name: Lint Release Notes

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  lint:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Install dependencies
      run: sudo apt-get install -y jq curl

    - name: Run linter script
      run: |
        #!/bin/bash

        # Error tracking
        errors=()

        # Function to validate date format
        validate_date_format() {
          date="$1"
          if ! [[ "$date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
            errors+=("Invalid date format: $date. Expected format: YYYY-MM-DD.")
          fi
        }

        # Function to validate allowed labels
        validate_labels() {
          allowed_labels=("kind/bug-fix" "N/A" "kind/feature" "kind/upgrade-consideration" "kind/breaking-change" "kind/api-change" "kind/deprecation" "impact/high" "impact/medium")
          labels=("$@")
          for label in "${labels[@]}"; do
            trimmed_label=$(echo "$label" | xargs)  # Trim spaces
            if [[ ! " ${allowed_labels[*]} " =~ " ${trimmed_label} " ]]; then
              errors+=("Invalid label: ${trimmed_label}. Allowed labels are: ${allowed_labels[*]}")
            fi
          done
        }

        # Function to validate curated release notes
        validate_curated_notes() {
          curated_file="$1"
          json_error=false

          # Check for valid JSON format
          if ! jq empty "$curated_file" 2>/dev/null; then
            errors+=("Invalid JSON format in file: $curated_file")
            json_error=true
          fi

          # Attempt to parse even if JSON format is invalid
          addon_name=$(jq -r '.addonName' "$curated_file" 2>/dev/null)
          version=$(jq -r '.version' "$curated_file" 2>/dev/null)
          release_date=$(jq -r '.releaseDate' "$curated_file" 2>/dev/null)
          notes=$(jq -c '.notes' "$curated_file" 2>/dev/null)

          if [[ -z "$addon_name" || -z "$version" || -z "$release_date" || -z "$notes" || "$notes" == "[]" ]]; then
            errors+=("Missing required fields or empty values in curated release notes: $curated_file")
          fi

          # Validate date format regardless of JSON error
          validate_date_format "$release_date"

          # Validate each note in the notes array
          if [[ "$notes" != "[]" ]]; then
            jq -c '.notes[]' "$curated_file" 2>/dev/null | while read -r note; do
              labels=$(echo "$note" | jq -r '.label[]' 2>/dev/null)
              text=$(echo "$note" | jq -r '.text' 2>/dev/null)

              if [[ -z "$labels" || -z "$text" ]]; then
                errors+=("Missing label or text in note in file: $curated_file")
              else
                # Convert labels to an array and validate each one
                IFS=$'\n' read -rd '' -a label_array <<<"$labels"
                validate_labels "${label_array[@]}"
              fi
            done
          fi
        }

        # Function to validate raw release notes
        validate_raw_notes() {
          raw_file="$1"
          if ! grep -q "^source: " "$raw_file"; then
            errors+=("Missing or incorrect source link in raw release notes: $raw_file")
          fi

          source_link=$(grep "^source: " "$raw_file" | awk '{print $2}')
          if ! curl --output /dev/null --silent --head --fail "$source_link"; then
            errors+=("Invalid source link: $source_link in file: $raw_file")
          fi
        }

        # Find and validate all release notes
        for curated_file in addons/*/curated/*/curated-release-notes.json; do
          validate_curated_notes "$curated_file"
        done

        for raw_file in addons/*/raw/*/raw-release-notes.txt; do
          validate_raw_notes "$raw_file"
        done

        # Report errors
        if [ ${#errors[@]} -ne 0 ]; then
          echo "Errors found during linting:"
          for error in "${errors[@]}"; do
            echo "- $error"
          done
          exit 1
        else
          echo "All release notes are valid."
        fi
